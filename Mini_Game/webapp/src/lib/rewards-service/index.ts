import { MiniGameKey } from "@/lib/game-core/types";

export interface RewardState {
  stickers: string[];
  chestLastOpenedDate: string | null;
  chestOpenCount: number;
  equippedAvatar: string | null;
  equippedPet: string | null;
  equippedTool: string | null;
  selfChallengeWinDate: string | null;
}

export interface TodayChallengeMetrics {
  date: string;
  rounds: number;
  correct: number;
  accuracy: number;
  byGame: Record<MiniGameKey, { rounds: number; correct: number; wrong: number }>;
}

export interface HistoricalChallengeMetrics {
  date: string;
  rounds: number;
  correct: number;
  accuracy: number;
}

export interface SelfChallengeStatus {
  target: {
    rounds: number;
    correct: number;
    accuracy: number;
  };
  progress: {
    rounds: number;
    correct: number;
    accuracy: number;
  };
  achieved: boolean;
  wonToday: boolean;
}

const STORAGE_KEY = "cvf-mini-rewards-v1";

const STICKER_POOL = [
  "Nova Ticket",
  "Orbit Key",
  "Starlight Lens",
  "Comet Pin",
  "Galaxy Shield",
  "Neon Trail",
  "Rocket Spark",
  "Nebula Badge",
  "Astro Patch",
  "Super Signal",
];

const AVATAR_POOL = ["Captain Kid", "Orbit Runner", "Nova Agent", "Galaxy Ace"];
const PET_POOL = ["Robo Pup", "Comet Fox", "Star Owl", "Nano Dragon"];
const TOOL_POOL = ["Lens Scanner", "Code Decoder", "Time Anchor", "Pattern Radar"];

function getTodayKey(now: Date = new Date()): string {
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function isStateLike(raw: unknown): raw is RewardState {
  if (!raw || typeof raw !== "object") return false;
  const item = raw as Partial<RewardState>;
  if (!Array.isArray(item.stickers)) return false;
  if (typeof item.chestOpenCount !== "number") return false;
  return true;
}

export function getDefaultRewardState(): RewardState {
  return {
    stickers: [],
    chestLastOpenedDate: null,
    chestOpenCount: 0,
    equippedAvatar: null,
    equippedPet: null,
    equippedTool: null,
    selfChallengeWinDate: null,
  };
}

export function loadRewardState(): RewardState {
  if (typeof window === "undefined") return getDefaultRewardState();
  try {
    const raw = window.localStorage.getItem(STORAGE_KEY);
    if (!raw) return getDefaultRewardState();
    const parsed = JSON.parse(raw) as unknown;
    if (!isStateLike(parsed)) return getDefaultRewardState();
    const state = parsed as RewardState;
    return {
      stickers: Array.from(new Set(state.stickers)).slice(0, STICKER_POOL.length),
      chestLastOpenedDate: state.chestLastOpenedDate ?? null,
      chestOpenCount: Math.max(0, Math.round(state.chestOpenCount)),
      equippedAvatar: state.equippedAvatar ?? null,
      equippedPet: state.equippedPet ?? null,
      equippedTool: state.equippedTool ?? null,
      selfChallengeWinDate: state.selfChallengeWinDate ?? null,
    };
  } catch {
    return getDefaultRewardState();
  }
}

export function saveRewardState(state: RewardState): void {
  if (typeof window === "undefined") return;
  try {
    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch {
    // Ignore write failures.
  }
}

function getUnlockCount(stickers: string[]): { avatars: number; pets: number; tools: number } {
  const count = stickers.length;
  return {
    avatars: Math.min(AVATAR_POOL.length, Math.max(1, Math.floor((count + 1) / 3))),
    pets: Math.min(PET_POOL.length, Math.max(1, Math.floor((count + 2) / 3))),
    tools: Math.min(TOOL_POOL.length, Math.max(1, Math.floor((count + 3) / 4))),
  };
}

export function getUnlockedAvatars(state: RewardState): string[] {
  const unlocked = getUnlockCount(state.stickers).avatars;
  return AVATAR_POOL.slice(0, unlocked);
}

export function getUnlockedPets(state: RewardState): string[] {
  const unlocked = getUnlockCount(state.stickers).pets;
  return PET_POOL.slice(0, unlocked);
}

export function getUnlockedTools(state: RewardState): string[] {
  const unlocked = getUnlockCount(state.stickers).tools;
  return TOOL_POOL.slice(0, unlocked);
}

function ensureEquipmentUnlocked(state: RewardState): RewardState {
  const unlockedAvatars = getUnlockedAvatars(state);
  const unlockedPets = getUnlockedPets(state);
  const unlockedTools = getUnlockedTools(state);
  const safeAvatar = unlockedAvatars.includes(state.equippedAvatar ?? "") ? state.equippedAvatar : unlockedAvatars[0] ?? null;
  const safePet = unlockedPets.includes(state.equippedPet ?? "") ? state.equippedPet : unlockedPets[0] ?? null;
  const safeTool = unlockedTools.includes(state.equippedTool ?? "") ? state.equippedTool : unlockedTools[0] ?? null;
  if (safeAvatar === state.equippedAvatar && safePet === state.equippedPet && safeTool === state.equippedTool) {
    return state;
  }
  return {
    ...state,
    equippedAvatar: safeAvatar,
    equippedPet: safePet,
    equippedTool: safeTool,
  };
}

export function equipAvatar(state: RewardState, avatar: string): RewardState {
  if (!getUnlockedAvatars(state).includes(avatar)) return state;
  return {
    ...state,
    equippedAvatar: avatar,
  };
}

export function equipPet(state: RewardState, pet: string): RewardState {
  if (!getUnlockedPets(state).includes(pet)) return state;
  return {
    ...state,
    equippedPet: pet,
  };
}

export function equipTool(state: RewardState, tool: string): RewardState {
  if (!getUnlockedTools(state).includes(tool)) return state;
  return {
    ...state,
    equippedTool: tool,
  };
}

export function syncStickersFromBadges(state: RewardState, badges: string[]): { nextState: RewardState; unlocked: string[] } {
  const normalizedBadges = badges.slice(0, STICKER_POOL.length);
  if (normalizedBadges.length === 0) {
    return {
      nextState: ensureEquipmentUnlocked(state),
      unlocked: [],
    };
  }

  const nextStickers = [...state.stickers];
  const unlocked: string[] = [];
  normalizedBadges.forEach((badge, idx) => {
    const stickerName = STICKER_POOL[idx] ?? badge;
    if (!nextStickers.includes(stickerName)) {
      nextStickers.push(stickerName);
      unlocked.push(stickerName);
    }
  });

  const next = ensureEquipmentUnlocked({
    ...state,
    stickers: nextStickers.slice(0, STICKER_POOL.length),
  });
  return {
    nextState: next,
    unlocked,
  };
}

export function openDailyChest(state: RewardState, now: Date = new Date()): {
  nextState: RewardState;
  opened: boolean;
  unlockedSticker: string | null;
} {
  const today = getTodayKey(now);
  if (state.chestLastOpenedDate === today) {
    return {
      nextState: state,
      opened: false,
      unlockedSticker: null,
    };
  }

  const candidates = STICKER_POOL.filter((item) => !state.stickers.includes(item));
  const unlockedSticker = candidates[0] ?? null;
  const nextStickers = unlockedSticker ? [...state.stickers, unlockedSticker] : [...state.stickers];

  const next = ensureEquipmentUnlocked({
    ...state,
    chestLastOpenedDate: today,
    chestOpenCount: state.chestOpenCount + 1,
    stickers: nextStickers.slice(0, STICKER_POOL.length),
  });

  return {
    nextState: next,
    opened: true,
    unlockedSticker,
  };
}

export function getSelfChallengeStatus(
  state: RewardState,
  today: TodayChallengeMetrics,
  previous: HistoricalChallengeMetrics | null,
): SelfChallengeStatus {
  const baseTarget = {
    rounds: Math.max(6, previous ? previous.rounds + 1 : 8),
    correct: Math.max(5, previous ? previous.correct + 1 : 7),
    accuracy: Math.max(65, previous ? Math.min(98, previous.accuracy + 2) : 72),
  };

  const progress = {
    rounds: today.rounds,
    correct: today.correct,
    accuracy: today.accuracy,
  };

  const achieved =
    progress.rounds >= baseTarget.rounds &&
    progress.correct >= baseTarget.correct &&
    progress.accuracy >= baseTarget.accuracy;

  return {
    target: baseTarget,
    progress,
    achieved,
    wonToday: state.selfChallengeWinDate === today.date,
  };
}

export function markSelfChallengeWin(state: RewardState, date: string): RewardState {
  if (state.selfChallengeWinDate === date) return state;
  return {
    ...state,
    selfChallengeWinDate: date,
  };
}
